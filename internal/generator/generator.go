package generator

import (
	"fmt"
	"strings"

	rpcerrormapperv1 "github.com/leetm4n/rpc-error-proto-mapper-go/api/proto/rpc/errormapper/v1"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

type generator struct {
	enums     []*protogen.Enum
	protoFile *protogen.File
	gen       *protogen.GeneratedFile
}

func (g *generator) Generate() {
	// this is the outline of generated code
	g.addHeaderComment()
	g.addEmptyLine()
	g.addPackageName()
	g.addEmptyLine()
	g.addImports([]string{
		"fmt",
		"google.golang.org/genproto/googleapis/rpc/code",
	})
	g.addEmptyLine()
	g.addMappers()
	g.addEmptyLine()
}

func (g *generator) addImports(imports []string) {
	g.gen.P("import (")

	for _, importValue := range imports {
		g.gen.P(fmt.Sprintf("  \"%s\"", importValue))
	}

	g.gen.P(")")
}

func (g *generator) addPackageName() {
	g.gen.P(fmt.Sprintf("package %s", g.protoFile.GoPackageName))
}

func (g *generator) addMappers() {
	for _, enum := range g.enums {
		g.addErrors(enum)
		g.addConstants(enum)
		g.addEmptyLine()
		g.addDecoderMapper(enum)
		g.addEmptyLine()
		g.addEncoders(enum)
		g.addEmptyLine()
	}
}

func (g *generator) addConstants(enum *protogen.Enum) {
	g.gen.P("const (")

	for _, value := range enum.Values {
		nameWithoutPrefix := stripEnumValuePrefix(value.GoIdent.GoName, enum.GoIdent.GoName)
		name := uppperSnakeCaseToPascalCase(nameWithoutPrefix)
		options := getOptions(value)

		if options == nil {
			continue
		}

		g.gen.P(fmt.Sprintf("  %sCode = %d", name, options.Code))
		g.gen.P(fmt.Sprintf("  %sDomain = \"%s\"", name, options.Domain))
		g.gen.P(fmt.Sprintf("  %sReason = \"%s\"", name, nameWithoutPrefix))
	}

	g.gen.P(")")
}

func getOptions(value *protogen.EnumValue) *rpcerrormapperv1.EnumValueLevelOptions {
	options, ok := proto.GetExtension(
		value.Desc.Options(),
		rpcerrormapperv1.E_Options.TypeDescriptor().Type(),
	).(*rpcerrormapperv1.EnumValueLevelOptions)

	if !ok {
		return nil
	}

	return options
}

func (g *generator) addErrors(enum *protogen.Enum) {
	for _, value := range enum.Values {
		name := uppperSnakeCaseToPascalCase(stripEnumValuePrefix(value.GoIdent.GoName, enum.GoIdent.GoName))

		g.gen.P(fmt.Sprintf("type %s struct{", name))
		g.gen.P("  code code.Code")
		g.gen.P("  reason string")
		g.gen.P("  domain string")
		g.gen.P("  metadata map[string]string")
		g.gen.P("}")

		g.addEmptyLine()

		g.gen.P(fmt.Sprintf("func (e %s) Error() string {", name))
		g.gen.P("  return fmt.Sprintf(\"%s: %s\", e.code, e.reason)")
		g.gen.P("}")

		g.addEmptyLine()

		g.gen.P(fmt.Sprintf("func (e %s) Code() code.Code {", name))
		g.gen.P("  return e.code")
		g.gen.P("}")

		g.addEmptyLine()

		g.gen.P(fmt.Sprintf("func (e %s) Reason() string {", name))
		g.gen.P("  return e.reason")
		g.gen.P("}")

		g.addEmptyLine()

		g.gen.P(fmt.Sprintf("func (e %s) Domain() string {", name))
		g.gen.P("  return e.domain")
		g.gen.P("}")

		g.addEmptyLine()

		g.gen.P(fmt.Sprintf("func (e %s) Metadata() map[string]string {", name))
		g.gen.P("  return e.metadata")
		g.gen.P("}")

		g.addEmptyLine()

		g.gen.P(fmt.Sprintf("func New%s(code code.Code, reason string, domain string, metadata map[string]string) %s {", name, name))
		g.gen.P(fmt.Sprintf("  return %s{", name))
		g.gen.P("    code: code,")
		g.gen.P("    reason: reason,")
		g.gen.P("    domain: domain,")
		g.gen.P("    metadata: metadata,")
		g.gen.P("  }")
		g.gen.P("}")
	}
}

func (g *generator) addDecoderMapper(enum *protogen.Enum) {
	g.gen.P(fmt.Sprintf("func %sDecoderMapper(code code.Code, reason, domain string, metadata map[string]string) error {", enum.GoIdent.GoName))
	g.gen.P("  switch reason {")
	for _, value := range enum.Values {
		nameWithoutPrefix := stripEnumValuePrefix(value.GoIdent.GoName, enum.GoIdent.GoName)
		name := uppperSnakeCaseToPascalCase(nameWithoutPrefix)

		g.gen.P(fmt.Sprintf("  case %sReason:", name))
		g.gen.P(fmt.Sprintf("    return New%s(code, reason, domain, metadata)", name))
	}
	g.gen.P("  default:")
	g.gen.P("    return fmt.Errorf(\"unknown reason: %s\", reason)")
	g.gen.P("  }")
	g.gen.P("}")
}

func (g *generator) addEncoders(enum *protogen.Enum) {
	for _, value := range enum.Values {
		g.addEncoder(value, enum)
	}
}

func (g *generator) addEncoder(value *protogen.EnumValue, enum *protogen.Enum) {
	name := uppperSnakeCaseToPascalCase(stripEnumValuePrefix(value.GoIdent.GoName, enum.GoIdent.GoName))

	g.gen.P(fmt.Sprintf("func %sEncoder(metadata map[string]string) (code.Code, string, string, map[string]string) {", name))
	g.gen.P(fmt.Sprintf("  return %sCode, %sReason, %sDomain, metadata", name, name, name))
	g.gen.P("}")
}

func (g *generator) addHeaderComment() {
	g.gen.P("// Code generated by protoc-gen-rpc-errormapper-go. DO NOT EDIT.")
	g.gen.P(fmt.Sprintf("// source: %s", *g.protoFile.Proto.Name))
}

func (g *generator) addEmptyLine() {
	g.gen.P()
}

func stripEnumValuePrefix(s, prefix string) string {
	return strings.TrimPrefix(s, fmt.Sprintf("%s_", prefix))
}

func uppperSnakeCaseToPascalCase(s string) string {
	words := strings.Split(s, "_")

	var str string
	for _, word := range words {
		str += cases.Title(language.Und).String(word)
	}
	return str
}

func New(
	enums []*protogen.Enum,
	protoFile *protogen.File,
	generatedFile *protogen.GeneratedFile,
) *generator {
	return &generator{
		enums:     enums,
		protoFile: protoFile,
		gen:       generatedFile,
	}
}
